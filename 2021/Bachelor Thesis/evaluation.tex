\section{Экспериментальное исследование}

\subsection{Постановка экспериментов}

Для экспериментов использовалась рабочая станция с процессором Intel Core i7-6790, тактовой частотой 3.40GHz, RAM DDR4 с объемом памяти 64Gb, видеокартой GeForce GTX 1070 с 8Gb VRAM, ОС под управлением Ubuntu 20.04.

\subsubsection*{Исследовательские вопросы}

Для того, чтобы стуктурировать исследование, были сформулированы следующие вопросы.

\begin{itemize}
   \item[\textbf{В1:}] Какова производительность отдельных операций реализвонной библиотеки примитивов разреженной линейной булевой алгебры на GPGPU по сравнению с существующими аналогами?
   
   \item[\textbf{В2:}] Какова производиетльность реализованного алгоритма поиска путей через тензорное произведение на GPGPU  по сравнению с существующими аналагами, также полагающимися на примтивы линейной алгебры? 
\end{itemize}

В1 направлен на определение эффективности отдельных матрицных операций в реализованной библиотеке. В качестве таких операций выступают \textit{матричное умножение} и \textit{матрицное сложение} в булевом полукольце, как наиболее распространненные и критически важные операции в прикладных алгоритмах. Для сравнения производительности в этих операциях предлагается использовать популярные существующие библиотеки разреженной линейной алгебры для платформ Nvidia Cuda, OpenCL и CPU, что позволит состваить наиболее полную картину. В качетсве таких библиотек ьыли выбраны были выбраны CUSP и cuSPRASE для Nvidia Cuda, clSPARSE для OpenCL, и SuiteSparse для CPU. CUSP предаставляет реализацию операций, основанную на шаблонах для параметризации используемого типа данных, однако библиотека не делает каких-либо дополнительных оптимизация конкретно для булевых значений. cuSPARSE и clSPRASE предоставляют операции только для основных типов данных с плавающей запятой. Однако данное ограничение можно обойти, если интерпретировать ненулевые значения как \textit{true}. Библиотека SuiteSprase является эталонной реализацией GraphBLAS API и имеет встроенное булево полукольцо для вычислений.

В2 направлен на определение эффективности реализованного алгоритма и его сравнение с алгоритмом Рустама Азимова~\cite{inproceedings:cfqp_matrix_with_single_source}, который также полагается на операции линейной булевой алгебры. Данный алгоритм также реализован с использованием разработанного в данной работе Python-пакета, что делает сравнение корректным.

\subsubsection*{Описание данных}

Для замеров производительности отдельных операций реализованной библиотеки были выбраны 10 различных квадратных матриц из известной коллекции университета Флориды~\cite{net:sp_matrix_data_florida} для проверки эффективности алгоритмов, реализующих операции над разряженными матрицами. 
Информация о матрицах представлена в таблице~\ref{table:sparse_matrices}. Для обозначения числа ненулевых элементов используется аббревиатура \textit{Nnz} (англ. number of non-zero elements). В таблице приведено официальное название матрицы, количество строк (соответсвует числу столбцов), а также количество ненулевых элментов в данной матрице и в производных от нее, полученных умножением матрицы самой на себя, что обозначается как степень $M^2$, и поэлементным сложением данной матрицы с собой также возведенной в степень, что обозначается как $M + M^2$.
Вычисление данных артефатков имитирует шаг транзитивного замыкания, которое явлеятся элементом многих алгоритов на графах, связанных с анализом достижимости. Эффективное вычисление этого шага во многом определяет производительность конечных алгоритмов.

\begin{table}[h]
\begin{center}
\caption{Разреженные матричные данные}
\label{table:sparse_matrices}
% \scriptsize
\rowcolors{2}{black!2}{black!10}
\scalebox{0.9}{
\begin{tabular}{|c|l|r|r|r|r|}
\hline
\textnumero&Матрица $M$ & Кол-во Строк  & Nnz $M$    & Nnz   $M^2$    & Nnz $M + M^2$    \\
\hline
\hline
0&  wing             &    62,032    &   243,088    &    714,200     &    917,178       \\
1&  luxembourg\_osm  &   114,599    &   239,332    &    393,261     &    632,185       \\
2&  amazon0312       &   400,727    & 3,200,400    & 14,390,544     & 14,968,909       \\
3&  amazon-2008      &   735,323    & 5,158,388    & 25,366,745     & 26,402,678       \\
4&  web-Google       &   916,428    & 5,105,039    & 29,710,164     & 30,811,855       \\
5&  roadNet-PA       & 1,090,920    & 3,083,796    &  7,238,920     &  9,931,528       \\
6&  roadNet-TX       & 1,393,383    & 3,843,320    &  8,903,897     & 12,264,987       \\
7&  belgium\_osm     & 1,441,295    & 3,099,940    &  5,323,073     &  8,408,599       \\
8&  roadNet-CA       & 1,971,281    & 5,533,214    & 12,908,450     & 17,743,342       \\
9&  netherlands\_osm & 2,216,688    & 4,882,476    &  8,755,758     & 13,626,132       \\ 
\hline
\end{tabular}
}
\end{center}
\end{table}

Для замеров производительности алгоритмов поиска путей с КС ограничениями используется коллекция графовых данных лаборатории языковых интсрументов JetBrains Research~\cite{net:cfpq_data}, которая использовались в ряде работ~\cite{inproceedings:matrix_cfpq, inproceedings:cfpq_matrix_evaluation, inbook:kronecker_cfpq_adbis, inproceedings:cfqp_matrix_with_single_source} для подобных экспериментов. Данная колекция содержит RDF данные, онтологии, графы программ для анализа указателей, а также ряд сгенерированных графов для анализа особых случаем. 

Данные, необходимые для замеров, предварительно загружаются в RAM или VRAM в формате, требуемом для тестируемого интсрумента. Время, необходимое на чтение данных с диска, их конвертацию, а также подготовку начального состояния входных матриц исключено из замеров. 

\subsubsection*{Метрики}

Для ответа на поставленные исследовательские вопросы в качестве метрик производительности используется время, требуемое для выполнения операции, а также пиковое количество потребяемой видеопамяти на GPU в момент вычисления. Показатели времени усреднены по 10 запускам. Предварительно совершался не учитывающийся в замерах запуск, чтобы проинициализировать начальное состояние тестируемых библиотек. Показатели потребления видеопамяти получены с помощью интсрумента \textit{nvidia-smi}, который с точностью до $1$ миллисикунды позволяет отслеживать количество потребляемой памяти процессом ОС на стороне видеокарты. 

\subsection{Результаты}

\textit{1) В1: Какова производительность отдельных операций реализвонной библиотеки примитивов разреженной линейной булевой алгебры на GPGPU по сравнению с существующими аналогами?}

\textit{2) В2: Какова производиетльность реализованного алгоритма поиска путей через тензорное произведение на GPGPU по сравнению с существующими аналагами, также полагающимися на примтивы линейной алгебры?}