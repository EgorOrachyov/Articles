\section*{Введение}

Все чаще современные системы аналитики и рекомендаций строятся на основе анализа данных, структурированных с использованием \textit{графовой модели}. В данной модели основные сущности представляются вершинами графа, а отношения между сущностями --- ориентированными ребрами с различными метками. Подобная модель позволяет относительно легко и практически в явном виде моделировать сложные иерархические структуры, которые не так просто представить, например, в классической \textit{реляционной модели}. В качестве основных областей применения графовой модели можно выделить следующие: графовые базы данных~\cite{article:querying_graph_databases}, анализ RDF данных~\cite{article:cfpq_and_rdf_analysis}, биоинформатика~\cite{article:rna_prediction} и статический анализ кода~\cite{article:dyck_cfl_code_analysis}.

Поскольку графовая модель используется для моделирования отношений между объектами, при решении прикладных задач возникает необходимость в выявлении более сложных взаимоотношений между объектами. Для этого чаще всего формируются запросы в специализированных программных средствах для управления графовыми базами данных. В качестве запроса можно использовать некоторый \textit{шаблон} на путь в графе, который будет связывать объекты, т.е. выражать взаимосвязь между ними. В качестве такого шаблона можно использовать формальные грамматики, например, регулярные или контекстно-свободные (КС). Используя вычислительно более выразительные грамматики, можно формировать более сложные запросы и выявлять нестандартные и скрытые ранее взаимоотношения между объектами. Например, \textit{same-generation queries}~\cite{inbook:databases_intro}, сходные с сбалансированными скобочными последовательностями Дика, могут быть выражены КС грамматиками, в отличие от регулярных.

Результатом запроса может быть множество пар объектов, между которыми существует путь в графе, удовлетворяющий заданным ограничениям. Также может возвращаться один экземпляр такого пути для каждой пары объектов или итератор всех путей, что зависит от семантики запроса. Поскольку один и тот же запрос может иметь разную семантику, требуются различные программные и алгоритмические средства для его выполнения.  

Запросы с регулярными ограничениями изучены достаточно хорошо, языковая и программная поддержка выполнения подобных запросов присутствует в некоторых в современных графовых базах данных. Однако, полноценная поддержка запросов с КС ограничениями до сих пор не представлена. Существуют алгоритмы~\cite{article:cfpq_and_rdf_analysis, article:hellings_cfpq, inproceedings:matrix_cfpq, inbook:kronecker_cfpq_adbis, article:cfpq_go_for_rdf} для вычисления запросов с КС ограничениями, но потребуется еще время, прежде чем появиться полноценная высокпроизводительная реализация одного из алгоритмов, способная обрабатывать реальные графовые данные.

Работы~\cite{inproceedings:cfpq_matrix_evaluation, inproceedings:cfqp_matrix_with_single_source} в качестве реализации алгоритма~\cite{inproceedings:matrix_cfpq} для выполнения запросов с КС ограничениями с семантикой достижимости и семантикой одного пути показывают, что возможно использовать GPGPU для выполнения наиболее вычислительно сложных частей алгоритма, что дает \textit{существенный} прирост в производительности. 

Недавно представленный алгоритм~\cite{inbook:kronecker_cfpq_adbis} для вычисления запросов с КС ограничениями полагается на операции линейной алгебры: произведение Кронекера (частный случай тензорного произведения), умножение и сложение матриц в полукольце булевой алгебры. Важной задачей является реализация данного алгоритма, так как он в сравнении с~\cite{inproceedings:cfqp_matrix_with_single_source} позволяет выполнять запросы для всех ранее упомянутых семантик, потенциально поддерживает б\'ольшие по размеру КС запросы, с незначительными накладными расходами позволяет выполнять запросы с регулярными ограничениями, а с реализацией на GPGPU позволит получить потенциально приемлемое время выполнения запрсов.