% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%

% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
%\documentclass[14pt]{matmex-diploma}
\documentclass[14pt]{matmex-diploma-custom}
\usepackage{multirow}
\usepackage{multirow}
\usepackage[table,xcdraw]{xcolor}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{lscape}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{latexsym}


\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Программная инженерия\\ Кафедра системного программирования},
    title              = {Реализация алгоритма поиска путей в графовых базах данных через тензорное произведение на GPGPU},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {bachelor},
    position           = {студента},
    group              = 471,
    author             = {Орачев Егор Станиславович},
    supervisorPosition = {к.\,ф.-м.\,н., доцент},
    supervisor         = {С. В. Григорьев},
%   reviewerPosition   = {ст. преп.},
%   reviewer           = {Привалов А.\,И.},
%   chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
%   chairHead          = {Хунта К.\,Х.},
    university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
    city               = {Санкт-Петербург},
    year               = {2020}
}

% \filltitle{en}{
%     chair              = {The Meaning of Life \\ Uselessness of Everything},
%     title              = {Empty subset as closed set},
%     author             = {Edelweis Mashkin},
%     supervisorPosition = {professor},
%     supervisor         = {Amvrosy Vibegallo},
%     reviewerPosition   = {assistant},
%     reviewer           = {Alexander Privalov},
%     chairHeadPosition  = {professor},
%     chairHead          = {Christobal Junta},
% }

\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}

Все чаще современные системы аналитики и рекомендаций строятся на основе анализа данных, структурированных с использованием \textit{графовой модели}. В данной модели основные сущности представляются вершинами графа, а отношения между сущностями --- ориентированными ребрами с различными метками. Подобная модель позволяет относительно легко и практически в явном виде моделировать сложные иерархические структуры, которые не так просто представить, например, в классической \textit{реляционной модели}. В качестве основных областей применения графовой модели можно выделить следующие: графовые базы данных~\cite{article:querying_graph_databases}, анализ RDF данных~\cite{DBLP:journals/corr/ZhangFWR15}, биоинформатика~\cite{article:rna_prediction} и статический анализ кода~\cite{article:dyck_cfl_code_analysis}.

Поскольку графовая модель используется для моделирования отношений между объектами, при решении прикладных задач возникает необходимость выявления более сложных взаимоотношений между объектам и. Для этого чаще всего формируются запросы в специализированных программных средствах для управления графовыми базами данных. В качестве запроса можно использовать некоторый \textit{шаблон} на путь в графе, который будет связывать объекты, т.е. выражать взаимосвязь между ними. В качестве такого шаблона можно использовать формальные грамматики, например, регулярные или контекстно-свободные (КС). Используя вычислительно более выразительные грамматики, можно формировать более сложные запросы и выявлять нестандартные и скрытые ранее взаимоотношения между объектами. Например, \textit{same-generation queries}~\cite{inbook:databases_intro}, сходные с сбалансированными скобочными последовательностями Дика, могут быть выражены КС грамматиками, в отличие от регулярных.

Результатом запроса может быть множество пар объектов, между которыми существует путь в графе, удовлетворяющий заданным ограничениям. Также может возвращаться один экземпляр такого пути для каждой пары объектов или итератор всех путей, что зависит от семантики запроса. Поскольку один и тот же запрос может иметь разную семантику, требуются различные программные и алгоритмические средства для его выполнения.  

Запросы с регулярными ограничениями изучены достаточно хорошо, языковая и программная поддержка выполнения подобных запросов присутствует в некоторых в современных графовых базах данных. Однако, полноценная поддержка запросов с КС ограничениями до сих пор не представлена. Существуют алгоритмы~\cite{DBLP:journals/corr/ZhangFWR15, article:hellings_cfpq, inproceedings:matrix_cfpq, inbook:kronecker_cfpq_adbis, article:cfpq_go_for_rdf} для вычисления запросов с КС ограничениями, но потребуется еще время, прежде чем появиться полноценная высокпроизводительная реализация одного из алгоритмов, способная обрабатывать реальные графовые данные.

Работы~\cite{inproceedings:cfpq_matrix_evaluation, inproceedings:cfqp_matrix_with_single_source} в качестве реализации алгоритма~\cite{inproceedings:matrix_cfpq} показывают, что возможно использовать GPGPU для выполнения наиболее вычислительно сложных частей алгоритма, что дает \textit{существенный} прирост в производительности. Недавно представленный алгоритм~\cite{inbook:kronecker_cfpq_adbis} для вычисления запросов с КС ограничениями полагается на операции линейной алгебры: произведение Кронекера (частный случай тензорного произведения), умножение и сложение матриц в полукольце булевой алгебры. Данный алгоритм в сравнении с~\cite{inproceedings:matrix_cfpq} позволяет выполнять запросы для всех ранее упомянутых семантик, потенциально поддерживает б\'ольшие по размеру КС запросы, с незначительными накладными расходами позволяет выполнять запросы с регулярными ограничениями, а также хорошо реализуется с помощью программных средств для вычисления на GPGPU.

Таким образом, важной задачей является реализация и апробация перспективного алгоритма~\cite{inbook:kronecker_cfpq_adbis} для выполнения запросов с КС и регулярными ограничениям, а также разработка программной библиотеки для работы с примитивами линейной булевой алгебры, которая позволила бы упростить прототипирование и реализацию подобного и будущих алгоритмов на GPGPU, в частности, на платформе NVIDIA CUDA~\cite{net:cuda_toolkit_docs}.

\section{Постановка задачи}

Цель данной работы --- реализация алгоритма поиска путей в графовых базах данных через тензорное произведение на платформе NVIDIA CUDA в качестве GPGPU технологии. Для ее достижения были поставлены следующие задачи:

\begin{itemize}
    \item Реализация библиотеки для работы с примитивами булевой алгебры на GPGPU
    \item Реализация интерфейса для работы с примитивами библиотеки в тестовой инфраструктуре
    \item Реализация алгоритма поиска путей с КС ограничениями
    % \item Реализация алгоритма восстановления путей
    \item Апробация алгоритма с использованием синтетических и реальных данных
\end{itemize}

\section{Обзор предметной области}

\subsection{Предварительные знания}

В этой секции изложены основные определения и факты из теории графов и формальных языков, необходимые для понимания предметной области. 
    
Ориентированный граф с метками $\mathcal{G} = (V, E, L)$ это тройка объектов, где $V$ конечное непустое множество вершин графа, $E \subseteq V \times L \times V$ конечное множество ребер графа, $L$ конечное множество меток графа. Здесь и далее будем считать, что вершины графа индексируются целыми числами, т.е. $V = \{0~...~|V| - 1\}$.

Граф $\mathcal{G} = (V, E, L)$ можно представить в виде матрицы смежности $M$ размером $|V| \times |V|$, где $M[i,j] = \{l~|~(i,l,j) \in E\}$. Используя булеву матричную декомпозицию, можно представить матрицу смежности в виде набора матриц $\mathcal{M} = \{ M^l ~|~ l \in L, M^l[i,j] = 1 \iff l \in M[i,l]\}$ 

Путь $\pi$ в графе $\mathcal{G} = (V, E, L)$ это последовательность ребер $e_0,e_1,e_{n-1}$, где $e_i = (v_i, l_i, u_i) \in E$ и для любых $e_i, e_{i+1}: u_i = v_{i+1}$. Путь между вершинами $v$ и $u$ будем обозначать как $v \pi u$. Слово, которое формирует путь $\pi = (v_0, l_0, v_1), ... ,(v_{n-1}, l_{n-1}, v_n)$ будем обозначать как $\omega (\pi) = l_0 ... l_{n-1}$, что является конкатенацией меток вдоль этого пути $\pi$.

Язык $L$ над конечным алфавитом символов $\Sigma$ это множество всевозможных слов, составленных из символов этого алфавита, т.е. $L = \{\omega~|~w \in \Sigma ^*\}$

Контекстно-свободная грамматика $G = (\Sigma, N, P, S)$ это четверка объектов, где $\Sigma$ конечное множестве терминалов или алфавит, $N$ конечное множество нетерминалов, $P$ конечное множество правил вывода вида $A \rightarrow \gamma, \gamma \in (N \cup \Sigma)^*$, $S \in N$ стартовый нетерминал. 

\subsection{Поиск путей с регулярными и КС ограничениями}

При вычислении запроса $p$ на поиск путей в графе $\mathcal{G} = (V, E, L)$ в качестве ограничения выступает некоторое множество слов $L$, которому должны удовлетворять результирующие пути. Если множество слов $L$ задается регулярным выражением, то считаем, что запрос $p$ имеет регулярные ограничения, если $L$ задается КС грамматикой, тогда $p$ имеет КС ограничения.

Поиск путей в графе с семантикой \textit{достижимости}, это поиск всех таких пар вершин $(v,u)$, что между ними существует путь $v \pi u$, такой что $\omega (\pi) \in L$. Результат запроса обозначается как $R = \{ (v,u)~|~\exists v \pi u : \omega (\pi) \in L \}$.

Поиск путей в графе с семантикой \textit{всех путей}, это поиск всех таких путей $v \pi u$,   что $\omega (\pi) \in L$. Результат запроса обозначается как $\Pi = \{ v \pi u~|~v \pi u : \omega (\pi) \in L \}$.

Необходимо отметить, что множество $\Pi$ может быть бесконечным, поэтому предполагается в качестве результата запроса не множества $Pi$ в явном виде, а некоторый \textit{итератор} или алгоритм, который позволит последовательно извлекать все пути.

\subsection{Существующие решения}

\subsection{Поиск путей через произведение Кронекера}

Прежде чем рассмотреть алгоритм поиска путей через произведение Кронекера, еще раз обратимся к теории формальных языков и некоторым элементам линейной алгебры, чтобы выработать на интуитивном уровне понимание идеи алгоритма.

Детерминированный конечный автомат (ДКА) $F = (\Sigma, Q, Q_s, Q_f, \delta)$ это пятерка объектов, где $\Sigma$ конечное множество входных символов или алфавит, $Q$ конечное множество состояний, $Q_s \subseteq Q$ множество стартовых состояний, $Q_f \subseteq Q$ множество конечных состояний, $\delta : \Sigma \times Q \rightarrow Q$ функция переходов автомата.

Рекурсивный автомат (РА) $R = (M, m, \{C_i\}_{i \in M})$ это тройка объектов, где $M$ конечное множество меток компонентных ДКА, называемых далее \textit{модули}, $m$ метка стартового модуля, $\{C_i\}$ множество модулей, где модуль $C_i = (\Sigma \cup M, Q_i, q_i^0, F_i, \delta _i): $ состоит из:

\begin{itemize}
    \item $\Sigma \cup M$ множество символов модуля, $\Sigma \cap M = \emptyset$
    \item $Q_i$ конечное множество состояний модуля, $Q_i \cap Q_j = \emptyset, \forall i \neq j$
    \item $q_i^0$ стартовое состояние модуля
    \item $F_i \subseteq Q_i$ множество конечных состояний модуля 
    \item $\delta_i : Q_i \times (\Sigma \cup M) \rightarrow Q_i$ функция переходов
\end{itemize}

Рекурсивный автомат ведет себя как набор ДКА или модулей~\cite{article:recursive_state_machines}. Эти модули очень сходны с ДКА при обработке входных последовательностей символов, однако модули РА способны обрабатывать дополнительные \textit{рекурсивные вызовы} за счет неявного \textit{стека вызовов}, который присутствует во время работы РА. С точки зрения прикладного программиста это похоже на рекурсивные вызовы одних функций из других с той разницей, что вместо функций здесь выступают модули РА.

Любое регулярное выражение может быть преобразовано в соответствующий ДКА без $\varepsilon$-переходов~\cite{book:automata_theory}. 

Согласно~\cite{article:recursive_state_machines} рекурсивные автоматы по своей вычислительной мощности эквивалентны автоматам на основе стека. А поскольку подобный стековый автомат способен распознавать КС грамматику~\cite{book:automata_theory}, рекурсивные автоматы эквивалентны КС грамматикам.

% \section{Реализация библиотеки матричных операций}

% \section{Реализация алгоритма}

% \section{Экспериментальное исследование}

% У заключения нет номера главы
% \section*{Заключение}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{kronecker_cfpq_gpu.bib}
\end{document}
