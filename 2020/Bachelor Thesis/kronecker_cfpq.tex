\section{Поиск путей с КС ограничениями через произведение Кронекера}

Недавно представленный алгоритм~\cite{inbook:kronecker_cfpq_adbis} для выполнения КС запросов использует подобную технику сведения вычислений к операциям булевой алгебры: произведению Кронекера, матричному умножению и сложению. Однако структура алгоритма такова, что он позволяет выполнять запросы сразу в семантике достижимости и семантике всех путей, способен работать с КС грамматиками существенно большего размера, также имеет относительно небольшие накладные расходы при вычислении запросов с регулярными ограничениями, что делает его потенциально применимым для решения этого класса проблем. 

\subsection{Рекурсивный автомат}

Для представления входной грамматики КС запроса алгоритм~\cite{inbook:kronecker_cfpq_adbis} использует \textit{рекурсивный автомат}. Данный формализм является своего рода обобщением \textit{детерминированного конечного автомата} на случай КС языков. Для понимания того, как он устроен, обратимся к теории формальных языков.

\textit{Конечный автомат} (КА) $F = \langle \Sigma, Q, Q_s, Q_f, \delta \rangle$ это пятерка объектов, где $\Sigma$ конечное множество входных символов или алфавит, $Q$ конечное множество состояний, $Q_s \subseteq Q$ множество стартовых состояний, $Q_f \subseteq Q$ множество конечных состояний, $\delta : \Sigma \times Q \rightarrow 2^Q$ функция переходов автомата. Язык, допускаемый автоматом $F$ будем обозначать как $L(F)$. Любое регулярное выражение может быть преобразовано в соответствующий КА~\cite{book:automata_theory}. 

\textit{Рекурсивный автомат} (РА) $R = \langle M, m, \{C_i\}_{i \in M} \rangle$ это тройка объектов, где $M$ конечное множество меток компонентных КА, называемых далее \textit{модули}, $m$ метка стартового модуля, $\{C_i\}$ множество модулей, где модуль $C_i = \langle \Sigma \cup M, Q_i, S_i, F_i, \delta _i \rangle: $ состоит из:

\begin{itemize}
    \item $\Sigma \cup M$ множество символов модуля, $\Sigma \cap M = \emptyset$
    \item $Q_i$ конечное множество состояний модуля, $Q_i \cap Q_j = \emptyset, \forall i \neq j$
    \item $S_i \subseteq Q_i$ множество стартовых состояний модуля
    \item $F_i \subseteq Q_i$ множество конечных состояний модуля 
    \item $\delta_i : (\Sigma \cup M) \times Q_i \rightarrow 2^{Q_i}$ функция переходов
\end{itemize}

Рекурсивный автомат ведет себя как набор КА или модулей~\cite{article:recursive_state_machines}. Эти модули очень сходны с КА при обработке входных последовательностей символов, однако они способны обрабатывать дополнительные \textit{рекурсивные вызовы} за счет неявного \textit{стека вызовов}, который присутствует во время работы РА. С точки зрения прикладного программиста это похоже на рекурсивные вызовы одних функций из других с той разницей, что вместо функций здесь выступают модули РА.

Рекурсивные автоматы по своей вычислительной мощности эквивалентны автоматам на основе стека~\cite{article:recursive_state_machines}. А поскольку подобный стековый автомат способен распознавать КС грамматику~\cite{book:automata_theory}, рекурсивные автоматы эквивалентны КС грамматикам. Это позволяет корректно использовать РА для представления входной КС грамматики запроса.

\subsection{Пересечение рекурсивного автомата и графа}

Классический алгоритм~\cite{book:automata_theory} \textit{пересечения} двух КА $F^1$ и $F^2$ позволяет построить новый КА $F$ с таким свойством, что он допускает пересечение исходных регулярных языков, т.е. $L(F) = L(F^1) \cap L(F^2)$. Формально, для $F^1 = \langle \Sigma, Q^1, Q^1_S, Q^1_F, \delta^1 \rangle$ и $F^2 = \langle \Sigma, Q^2, Q^2_S, Q^2_F, \delta^2 \rangle$ строится новый КА $F = \langle \Sigma, Q, Q_S, Q_F, \delta \rangle$, где $Q = Q^1 \times Q^2$, $Q_S = Q^1_S \times Q^2_S$, $Q_F = Q^1_F \times Q^2_F$, $\delta: \Sigma \times Q \rightarrow Q$ и $\delta(s, \langle q_1, q_2 \rangle) = \langle q'_1, q'_2 \rangle$, если $\delta^1 (s, q_1)=q'_1$ и $\delta^2 (s, q_2)=q'_2$. 

Интерпретируя ориентированный граф с метками как некоторый конечный автомат, в котором все вершины графа являются одновременно начальными и конечными состояниями автомата, а ребра графа --- переходами между состояниями автомата, возможно пересечь этот граф и некоторый КА, используя алгоритм пересечения, описанный выше. Однако, если представить граф и функцию переходов КА, тоже интерпретируемую как граф, в виде матриц смежности, можно использовать \textit{произведение Кронекера} для построения функции переходов автомата пересечения.

\textit{Произведение Кронекера} для двух матриц $A$ и $B$ размера $m_1 \times n_1$ и $m_2 \times n_2$ с поэлементной операцией умножения $\cdot$ дает матрицу $M = A \otimes B$ размером $m_1 * m_2 \times n_1 * n_2$, где $M[u * m_2 + v, p * n_2 + q] = A[u, p] \cdot B[v, q]$. 

Поскольку РА состоит из набора модулей, которые по своей структуре не сильно отличаются от классических КА, это дает идею для применения похожего алгоритма пересечения РА и графа, с той  разницей, что процесс пересечения будет итеративным и будет включать в себя транзитивное замыкание, чтобы учесть \textit{рекурсивные вызовы}, присутствующие в РА. 

\subsection{Описание алгоритма}

В листинге~\ref{tensor:cfpq} представлен псевдокод алгоритма~\cite{inbook:kronecker_cfpq_adbis}. Необходимо отметить, что алгоритм использует булеву матричную декомпозицию в строках \textbf{3 -- 4} для представления матрицы переходов РА и матрицы смежности графа, а также использует матричное умножение, сложение и произведение Кронекера в строках \textbf{14 -- 16}.

Данный алгоритм является относительно простым и компактным, так как всю сложность выполнения он перекладывает на операции линейной алгебры, которые должны быть реализованы в сторонних высокопроизводительных библиотеках.

\begin{algorithm}[h]
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\footnotesize
\caption{Поиск путей через произведение Кронекера}
\label{tensor:cfpq}
\Function{KroneckerProductBasedCFPQ}{G, $\mathcal{G}$}
    % Input data preparation
    \State{$R \gets$ Рекурсивный автомат для грамматики $G$}
    \State{$\mathcal{M}_1 \gets$ Матрица переходов $R$ в булевой форме}
    \State{$\mathcal{M}_2 \gets$ Матрица смежности $\mathcal{G}$ в булевой форме}
    \State{$C_3 \gets$ Пустая матрица}
    % Eps-transition handling for graph
    \For{$s \in \{0,...,dim(\mathcal{M}_1)-1\}$}
        \For{$S \in \textit{getNonterminals}(R,s,s)$}
            \For{$i \in \{0,...,dim(\mathcal{M}_2)-1\}$}
                % Or just $M_2^n[i,i] \gets M_2^n[i,i] \vee \{1\}$ ??? 
                \State{$M_2^S[i,i] \gets \{1\}$}
            \EndFor
        \EndFor
    \EndFor
    \While{Матрица смежности $\mathcal{M}_2$ изменяется}
        % Kronecker product (i.e. partial intersection)
        \State{$\mathcal{M}_3 \gets \mathcal{M}_1 \otimes \mathcal{M}_2$}
        \Comment{Вычисление произведения Кронекера}
        % Collapse to single Boolean matrix
        \State{$M'_3 \gets \bigvee_{M_3^a \in \mathcal{M}_3} M_3^a $}
        \Comment{Слияние матриц в одну булеву матрицу достижимости}
        % Closure over Boolean matrix only
        \State{$C_3 \gets \textit{transitiveClosure}(M'_3)$}
        \Comment{Транзитивное замыкание для учета рекурсивных вызовов}
        \State{$n \times n \gets$ dim($M_3)$}
        % Add non-terminals (possibly new)
        \For{$(i,j) \in \{0,...,n-1\} \times \{0,...,n-1\}$}
            \If{$C_3[i,j]$}
                \State{$s, f \gets \textit{getStates}(C_3,i,j)$}
                \State{$x, y \gets \textit{getCoordinates}(C_3,i,j)$}
                \For{$S \in \textit{getNonterminals}(R,s,f)$}
                    \State{$M_2^S[x,y] \gets \{1\}$}
                \EndFor
            \EndIf
        \EndFor
    \EndWhile
\State \Return $\mathcal{M}_2,C_3$
\EndFunction
\end{algorithmic}
\end{algorithm}

% \begin{algorithm}[]
% \floatname{algorithm}{Listing}
% \begin{algorithmic}[1]
% \footnotesize
% \caption{Вспомогательные функции для алгоритма поиска путей}
% \label{tensor:cfpq:help}
% \Function{GetStates}{$C, i, j$}
%     \State{$r \gets dim(\mathcal{M}_1)$}
%     \Comment{$\mathcal{M}_1$ матрица переходов в булевой форме для $R$}
%     \State \Return{$\left\lfloor{i / r}\right\rfloor, \left\lfloor{j / r}\right\rfloor$}
% \EndFunction
% \Function{GetCoordinates}{$C, i, j$}
%     \State{$n \gets dim(\mathcal{M}_2)$}
%     \Comment{$\mathcal{M}_2$ матрица смежности в булевой форме для $\mathcal{G}$}
%     \State \Return{$i \bmod n, j \bmod n$}
% \EndFunction
% \end{algorithmic}
% \end{algorithm}

% todo: paths extraction algorithm
% \subsection{Извлечение всех путей}