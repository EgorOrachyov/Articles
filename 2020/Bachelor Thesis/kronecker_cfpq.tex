\section{Поиск путей с КС ограничениями через произведение Кронекера}

Алгоритм~\cite{inbook:kronecker_cfpq_adbis} для выполнения КС запросов использует операции булевой линейной  алгебры: произведение Кронекера, матричное умножение и сложение, позволяет выполнять запросы в семантике достижимости и всех путей, а также подлежит распараллеливанию на многоядерных системах, что делает его потенциально применимым для анализа реальных данных. Далее предлагается рассмотреть описание данного алгоритма и используемую им технику сведения вычислений к операциям линейной алгебры.

\subsection{Рекурсивный автомат}

Для представления входной грамматики КС запроса алгоритм~\cite{inbook:kronecker_cfpq_adbis} использует \textit{рекурсивный автомат}. Данный формализм является своего рода обобщением \textit{недетерминированного конечного автомата} на случай КС языков. Для понимания того, как он устроен, обратимся к теории формальных языков.

\textit{Недетерминированный конечный автомат} (НКА) $F = \langle \Sigma, Q, Q_s, Q_f, \delta \rangle$ это пятерка объектов, где $\Sigma$ конечное множество входных символов или алфавит, $Q$ конечное множество состояний, $Q_s \subseteq Q$ множество стартовых состояний, $Q_f \subseteq Q$ множество конечных состояний, $\delta : \Sigma \times Q \rightarrow 2^Q$ функция переходов автомата. Язык, допускаемый автоматом $F$ будем обозначать как $L(F)$. Любое регулярное выражение может быть преобразовано в соответствующий НКА~\cite{book:automata_theory}. 

\textit{Рекурсивный автомат} (РА) $R = \langle M, m, \{C_i\}_{i \in M} \rangle$ это тройка объектов, где $M$ конечное множество меток компонентных НКА, называемых далее \textit{модули}, $m$ метка стартового модуля, $\{C_i\}$ множество модулей, где модуль $C_i = \langle \Sigma \cup M, Q_i, S_i, F_i, \delta _i \rangle: $ состоит из:

\begin{itemize}
    \item $\Sigma \cup M$ множество символов модуля, $\Sigma \cap M = \emptyset$
    \item $Q_i$ конечное множество состояний модуля, $Q_i \cap Q_j = \emptyset, \forall i \neq j$
    \item $S_i \subseteq Q_i$ множество стартовых состояний модуля
    \item $F_i \subseteq Q_i$ множество конечных состояний модуля 
    \item $\delta_i : (\Sigma \cup M) \times Q_i \rightarrow 2^{Q_i}$ функция переходов
\end{itemize}

Рекурсивный автомат ведет себя как набор НКА или модулей~\cite{article:recursive_state_machines}. Эти модули очень сходны с НКА при обработке входных последовательностей символов, однако они способны обрабатывать дополнительные \textit{рекурсивные вызовы} за счет неявного \textit{стека вызовов}, который присутствует во время работы РА. С точки зрения прикладного программиста это похоже на рекурсивные вызовы одних функций из других с той разницей, что вместо функций здесь выступают модули РА.

Рекурсивные автоматы по своей вычислительной мощности эквивалентны автоматам на основе стека~\cite{article:recursive_state_machines}. А поскольку подобный стековый автомат способен распознавать КС грамматику~\cite{book:automata_theory}, рекурсивные автоматы эквивалентны КС грамматикам. Это позволяет корректно использовать РА для представления входной КС грамматики запроса.

\subsection{Пересечение рекурсивного автомата и графа}

Классический алгоритм~\cite{book:automata_theory} \textit{пересечения} двух НКА $F^1$ и $F^2$ позволяет построить новый НКА $F$ с таким свойством, что он допускает пересечение исходных регулярных языков, т.е. $L(F) = L(F^1) \cap L(F^2)$. Формально, для $F^1 = \langle \Sigma, Q^1, Q^1_S, Q^1_F, \delta^1 \rangle$ и $F^2 = \langle \Sigma, Q^2, Q^2_S, Q^2_F, \delta^2 \rangle$ строится новый КА $F = \langle \Sigma, Q, Q_S, Q_F, \delta \rangle$, где $Q = Q^1 \times Q^2$, $Q_S = Q^1_S \times Q^2_S$, $Q_F = Q^1_F \times Q^2_F$, $\delta: \Sigma \times Q \rightarrow Q$ и $\delta(s, \langle q_1, q_2 \rangle) = \langle q'_1, q'_2 \rangle$, если $\delta^1 (s, q_1)=q'_1$ и $\delta^2 (s, q_2)=q'_2$. 

Интерпретируя ориентированный граф с метками как некоторый конечный автомат, в котором все вершины графа являются одновременно начальными и конечными состояниями автомата, а ребра графа --- переходами между состояниями автомата, возможно пересечь этот граф и некоторый НКА, используя алгоритм пересечения, описанный выше. Однако, если представить граф и функцию переходов КА, тоже интерпретируемую как граф, в виде матриц смежности, можно использовать \textit{произведение Кронекера} для построения функции переходов автомата пересечения.

\textit{Произведение Кронекера} для двух матриц $A$ и $B$ размера $m_1 \times n_1$ и $m_2 \times n_2$ с поэлементной операцией умножения $\cdot$ дает матрицу $M = A \otimes B$ размером $m_1 * m_2 \times n_1 * n_2$, где $M[u * m_2 + v, p * n_2 + q] = A[u, p] \cdot B[v, q]$. 

Поскольку РА состоит из набора модулей, которые по своей структуре не сильно отличаются от классических НКА, это дает идею для применения похожего алгоритма пересечения РА и графа, с той  разницей, что процесс пересечения будет итеративным и будет включать в себя транзитивное замыкание, чтобы учесть \textit{рекурсивные вызовы}, присутствующие в РА. 

\subsection{Описание алгоритма}

В листинге~\ref{tensor:cfpq} представлен псевдокод алгоритма~\cite{inbook:kronecker_cfpq_adbis}. Необходимо отметить, что алгоритм использует булеву матричную декомпозицию в строках \textbf{3 -- 4} для представления матрицы переходов РА и матрицы смежности графа, а также использует матричное умножение, сложение и произведение Кронекера в строках \textbf{14 -- 16}.

Данный алгоритм является относительно простым и компактным, так как всю сложность выполнения он перекладывает на операции линейной алгебры, которые должны быть реализованы в сторонних высокопроизводительных библиотеках.

\begin{algorithm}[h]
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\footnotesize
\caption{Поиск путей через произведение Кронекера}
\label{tensor:cfpq}
\Function{KroneckerProductBasedCFPQ}{G, $\mathcal{G}$}
    % Input data preparation
    \State{$R \gets$ Рекурсивный автомат для грамматики $G$}
    \State{$\mathcal{M}_1 \gets$ Матрица переходов $R$ в булевой форме}
    \State{$\mathcal{M}_2 \gets$ Матрица смежности $\mathcal{G}$ в булевой форме}
    \State{$C_3 \gets$ Пустая матрица}
    % Eps-transition handling for graph
    \For{$s \in \{0,...,dim(\mathcal{M}_1)-1\}$}
        \For{$S \in \textit{getNonterminals}(R,s,s)$}
            \For{$i \in \{0,...,dim(\mathcal{M}_2)-1\}$}
                % Or just $M_2^n[i,i] \gets M_2^n[i,i] \vee \{1\}$ ??? 
                \State{$M_2^S[i,i] \gets \{1\}$}
            \EndFor
        \EndFor
    \EndFor
    \While{Матрица смежности $\mathcal{M}_2$ изменяется}
        % Kronecker product (i.e. partial intersection)
        \State{$\mathcal{M}_3 \gets \mathcal{M}_1 \otimes \mathcal{M}_2$}
        \Comment{Вычисление произведения Кронекера}
        % Collapse to single Boolean matrix
        \State{$M'_3 \gets \bigvee_{M_3^a \in \mathcal{M}_3} M_3^a $}
        \Comment{Слияние матриц в одну булеву матрицу достижимости}
        % Closure over Boolean matrix only
        \State{$C_3 \gets \textit{transitiveClosure}(M'_3)$}
        \Comment{Транзитивное замыкание для учета рекурсивных вызовов}
        \State{$n \times n \gets$ dim($M_3)$}
        % Add non-terminals (possibly new)
        \For{$(i,j)~|~C[i,j] \neq 0$}
            \State{$s, f \gets \textit{getStates}(C_3,i,j)$}
            \State{$x, y \gets \textit{getCoordinates}(C_3,i,j)$}
            \For{$S \in \textit{getNonterminals}(R,s,f)$}
                \State{$M_2^S[x,y] \gets \{1\}$}
            \EndFor
        \EndFor
    \EndWhile
\State \Return $\mathcal{M}_2,C_3$
\EndFunction
\end{algorithmic}
\end{algorithm}

% \begin{algorithm}[]
% \floatname{algorithm}{Listing}
% \begin{algorithmic}[1]
% \footnotesize
% \caption{Вспомогательные функции для алгоритма поиска путей}
% \label{tensor:cfpq:help}
% \Function{GetStates}{$C, i, j$}
%     \State{$r \gets dim(\mathcal{M}_1)$}
%     \Comment{$\mathcal{M}_1$ матрица переходов в булевой форме для $R$}
%     \State \Return{$\left\lfloor{i / r}\right\rfloor, \left\lfloor{j / r}\right\rfloor$}
% \EndFunction
% \Function{GetCoordinates}{$C, i, j$}
%     \State{$n \gets dim(\mathcal{M}_2)$}
%     \Comment{$\mathcal{M}_2$ матрица смежности в булевой форме для $\mathcal{G}$}
%     \State \Return{$i \bmod n, j \bmod n$}
% \EndFunction
% \end{algorithmic}
% \end{algorithm}

% todo: paths extraction algorithm
% \subsection{Извлечение всех путей}

\subsection{Разработка библиотеки матричных операций}
 
\subsubsection{Мотивация}

Для эффективной реализации алгоритмов~\cite{inbook:kronecker_cfpq_adbis, inproceedings:matrix_cfpq} требуются высокопроизводительные библиотеки операций линейной алгебры. В качестве такой библиотеки для выполнения матричных операций на центральном процессоре авторы исследований использовали \textit{SuiteSparse}~\cite{net:suite_sparse}. Это эталонная реализация стандарта \textit{GraphBLAS}~\cite{net:graphblas}, который был разработан как некоторый инструмент для реализации алгоритмов обработки графов на языке линейной алгебры.  

Экспериментальное исследование~\cite{inproceedings:cfpq_matrix_evaluation} по реализации алгоритма Рустама Азимова~\cite{inproceedings:matrix_cfpq} на GPGPU с использованием операций над плотными булевыми матрицами показало, что вычисление на графическом процессоре дает значительный прирост производительности при обработке синтетических данных и данных среднего размера. Однако реальные графовые данные насчитывают порядка $10^5$ -- $10^9$ вершин и являются сильно разреженными, т.е. количество ребер в графе сравнимо с количеством вершин, поэтому плотные матрицы не подходят для представления такого типа данных. 

Естественным решением было бы использование библиотеки линейной алгебры над разреженными матрицами, которая использовала бы для своих вычислений графический процессор системы. Библиотеки \textit{NVIDIA cuSPARSE}~\cite{net:cusparse_docs} и \textit{CUSP}~\cite{net:cusplibrary} для платформы NVIDIA CUDA предоставляют подобную функциональность, однако они имеют специализацию только для стандартных типов данных, таких как \textit{float}, \textit{double}, \textit{int} и \textit{long}. Для реализации алгоритмов~\cite{inbook:kronecker_cfpq_adbis, inproceedings:matrix_cfpq} требуются операции над разреженными булевыми матрицами, поэтому требуется специализация вышеуказанных библиотек для работы с булевыми примитивами. С одной стороны, библиотека \textit{cuSPARSE} имеет закрытый исходный код, что делает невозможным ее модификацию, с другой стороны, библиотека \textit{CUSP} имеет открытый исходный код и свободную лицензию, однако используемый ею алгоритм умножения разреженных матриц \textit{слишком} требователен к ресурсам памяти, что делает его неприменимым для обработки графовых данных большого размера.

В работе~\cite{inproceedings:cfqp_matrix_with_single_source} была предпринята попытка реализовать с нуля алгоритм~\cite{inproceedings:spgemm_mem_saving_for_nvidia} умножения разреженных матриц и специализировать его для конкретно булевых значений. Данный алгоритм эксплуатирует возможности  видеокарт от NVIDIA и за счет б\'ольшего времени на обработку позволяет снизить количество расходуемой видеопамяти. Эксперименты показали, что подобный подход позволяет не только снизить в разы количество расходуемой видеопамяти, но и снизить общее время работы алгоритма~\cite{inproceedings:matrix_cfpq} по сравнению с его реализацией на \textit{CUSP}. 

Поэтому было принято решение расширить реализацию матричных операций из работы~\cite{inproceedings:cfqp_matrix_with_single_source}, дополнив ее требуемыми для алгоритма~\cite{inbook:kronecker_cfpq_adbis} примитивами, а также оформить решение в виде самостоятельной библиотеки, которая позволила бы в дальнейшем решать сходные вычислительные задачи.

\subsubsection{Примитивы и операции библиотеки}

Основным примитивом библиотеки является разреженная матрица булевых значений, которая хранится в видеопамяти видеокарты в формате \textit{CSR} (compressed sparse row), который позволяет использовать $O(V + E)$ памяти для хранения матрицы смежности графа. В качестве поэлементных операций сложения и умножения используются \textit{логическое-или} и \textit{логическое-и}. Основные функции работы с матрицами для реализации алгоритмов~\cite{inproceedings:cfqp_matrix_with_single_source, inbook:kronecker_cfpq_adbis} представлены ниже:

\begin{itemize}
    \item Создание матрицы $M$ размера $m \times n$
    \item Удаление матрицы $M$ и освобождение занятых ею ресурсов
    \item Заполнение матрицы $M$ списком значений $(i, j)$, где $i$ и $j$ обозначают строку и столбец ненулевого значения
    \item Чтение из матрицы $M$ списка значений $(i, j)$, где $i$ и $j$ обозначают строку и столбец ненулевого значения
    \item Сложение матриц $M + N$
    \item Умножение матриц $M * N$
    \item Произведение Кронекера для двух матриц $M \otimes N$
\end{itemize}

\subsubsection{Описание реализации}

Проект~\cite{net:cubool_project} опубликован на хостинге GitHub. В качестве языка программирования для написания реализации библиотеки выбран С++, так как он предоставляет механизмы для ручного управления ресурсами, а также позволяет работать с CUDA исполняемым кодом. Интерфейс библиотеки написан на языке С, что дает возможность использовать данную библиотеку в С компилируемых приложениях или экспортировать ее функции в среды с управляемыми ресурсами через механизмы исполнения стороннего кода.

Для работы конечного пользователя с разработанной библиотекой в тестовой инфраструктуре на языке Python был реализован слой совместимости, который экспортирует функции и примитивы библиотеки в среду исполнения Python и позволят автоматически управлять ресурсами. В качестве инструмента для вызова нативного исполняемого кода использовался стандартный для инфраструктуры Python модуль Ctypes.